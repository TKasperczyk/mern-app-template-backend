'use strict';

/**
 * Exposes a set of functions (controllers) that allow for interacting with our database models and performing other API tasks.
 */

const dotObj = require('dot-object');
const h = require('../helpers');
const logger = require('../logger').appLogger;
const mongoDb = require('../db').mongo.models;

/**
 * A set of generic CRUD functions that can be applied to any mongo database model.
 * It was created to avoid copy-pasting the same code for every database object
 */
const generics = {
    /**
     * @description allows for saving models in the mongo database
     * @param {Object}  [inputObj] the object that will be passed to the selected model's constructor
     * @param {String}  [modelName] full name of the model that will be saved
     * @param {Function}   [modifierFunc = null] a custom function that receives the newly created object as an argument. The function can modify that object before it gets saved in the database. The modifier should return the modified object. It's useful when we our inputObj is not complete and we want to do something with its default values defined in mongoose
     * @param {String}  [logPathPrefix = ''] by default, only the model name is appended to the identifier part of the log messages generated by this function. This parameter allows to add an additional identifier prefix if the model name is ambiguous
     * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
     * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
     * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
     * @returns {Object} the saved object with autopopulated properties and filled default values
     */
    add: async ({inputObj, modelName, modifierFunc = null, logPathPrefix = '', logging = true, callId = null}) => {
        //Generate a new callId for our logger if it wasn't passed in the parameters
        callId = h.generateCallId(callId);
        logger.api(`Adding a new ${modelName}`, {logging, identifier: `api ${logPathPrefix}${modelName} add`, meta: {inputObj}, callId});
        try{
            //Make sure that the input object is, in fact, an object
            if (inputObj === undefined || typeof inputObj !== 'object'){
                throw new Error('Wrong inputObj argument');
            }
            //Make sure that the given model exists in mongoose 
            if (typeof modelName !== 'string' || mongoDb[modelName] === undefined){
                throw new Error('Wrong modelName argument');
            }
            logger.api(`Creating a new ${modelName}`, {logging, identifier: `api ${logPathPrefix}${modelName} add`, callId});
            //Create a new instance of the given mongoose model
            let newObj = new mongoDb[modelName](inputObj);
            //Overwrite the generated object with the result of modifierFunc if it was passed as a parameter
            if (typeof modifierFunc === 'function'){
                newObj = modifierFunc(newObj);
            }
            logger.api(`Saving the new ${modelName}`, {logging, identifier: `api ${logPathPrefix}${modelName} add`, callId});
            //Save the generated object to the database
            const savedObj = await newObj.save();
            //If everything went fine, search for the created document and return it. We can't return the saved object directly because there might be some properties that should be autopopulated.
            if (savedObj){
                logger.api(`Successfully added a new ${modelName}`, {logging, identifier: `api ${logPathPrefix}${modelName} add`, meta: {savedObj}, callId});
                return mongoDb[modelName].findOne(savedObj._id); //For autopopopulate to work
            } else {
                throw new Error(`Failed to add a new ${logPathPrefix}${modelName}: unknown error`);
            }
        } catch (error){ //Log and rethrow
            logger.error(`Failed to add a new ${modelName}: ${h.optionalStringify(error)}`, {identifier: `api ${logPathPrefix}${modelName} add`, meta: {inputObj}, callId});
            throw error;
        }
    },
    /**
     * @description allows for deleting models from the mongo database
     * @param {String}  [id] the ID of the object that will be deleted
     * @param {String}  [modelName] full name of the model that will be saved
     * @param {String}  [logPathPrefix = ''] by default, only the model name is appended to the identifier part of the log messages generated by this function. This parameter allows to add an additional identifier prefix if the model name is ambiguous
     * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
     * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
     * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
     * @returns {Object} the deleted object with autopopulated properties and filled default values
     */
    delete: async ({id, modelName, logPathPrefix = '', logging = true, callId = null}) => {
        //Generate a new callId for our logger if it wasn't passed in the parameters
        callId = h.generateCallId(callId);
        logger.api(`Deleting a ${modelName}`, {logging, identifier: `api ${logPathPrefix}${modelName} delete`, meta: {id}, callId});
        try{
            //Check if the document ID is correct
            if (id === undefined || typeof id !== 'string' || !(/^[a-fA-F0-9]{24}$/).test(id)){
                throw new Error('Wrong id argument');
            }
            //Find and remove the document from the database
            const deletedObj = await mongoDb[modelName].findByIdAndRemove(id).exec();
            //If everything went fine, return the found and deleted document
            if (deletedObj){
                logger.api(`Successfully deleted a ${modelName} with an id: ${id}`, {logging, identifier: `api ${logPathPrefix}${modelName} delete`, meta: {deletedObj}, callId});
                return deletedObj;
            } else {
                throw new Error(`Failed to delete ${modelName} with id: ${id}`);
            }
        } catch (error){ //Log and rethrow
            logger.error(`Failed to delete an existing ${modelName}: ${h.optionalStringify(error)}`, {identifier: `api ${logPathPrefix}${modelName} delete`, meta: {id}, callId});
            throw error;
        }
    },
    /**
     * @description allows for updating models in the mongo database
     * @param {String}  [id] the ID of the object that will be updated
     * @param {Object}  [inputObj] the object that will be passed to the $set operator
     * @param {String}  [modelName] full name of the model that will be updated
     * @param {String}  [logPathPrefix = ''] by default, only the model name is appended to the identifier part of the log messages generated by this function. This parameter allows to add an additional identifier prefix if the model name is ambiguous
     * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
     * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
     * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
     * @returns {Object} the updated object with autopopulated properties and filled default values
     */
    update: async ({id, inputObj, modelName, logPathPrefix = '', logging = true, callId = null}) => {
        //Generate a new callId for our logger if it wasn't passed in the parameters
        callId = h.generateCallId(callId);
        logger.api(`Updating a ${modelName}`, {logging, identifier: `api ${logPathPrefix}${modelName} update`, meta: {id, inputObj}, callId});
        try{
            //Check if the document ID is correct
            if (id === undefined || typeof id !== 'string' || !(/^[a-fA-F0-9]{24}$/).test(id)){
                throw new Error(`Wrong id argument: ${id === undefined ? `undefined` : id} ${typeof id} ${typeof id === `string` ? !(/^[a-fA-F0-9]{24}$/).test(id) : 'regex not applicable'}`);
            }
            //Make sure that the input object is, in fact, an object
            if (inputObj === undefined || typeof inputObj !== 'object'){
                throw new Error(`Wrong inputObj argument`);
            }
            //Make sure that the given model exists in mongoose 
            if (typeof modelName !== 'string' || mongoDb[modelName] === undefined){
                throw new Error('Wrong modelName argument');
            }
            //We will pass the input object in a dotted form because that's what mongoose expects in the $set parameter
            inputObj = dotObj.dot(inputObj);
            //Update the document
            const updateResult = await mongoDb[modelName].updateOne({_id: id}, {$set: inputObj}, {new: false});
            //If everything wen't fine, find the updated object and return it (for autopopulate to work)
            if (updateResult.ok){
                logger.api(`Successfully updated a ${modelName} with an id: ${id}`, {logging, identifier: `api ${logPathPrefix}${modelName} update`, meta: {updateResult}, callId});
                return await mongoDb[modelName].findById(id);
            } else {
                throw new Error(`Failed to update ${modelName} with id: ${id}`);
            }
        } catch (error){ //Log and rethrow
            logger.error(`Failed to update an existing ${modelName}: ${h.optionalStringify(error)}`, {identifier: `api ${logPathPrefix}${modelName} update`, meta: {id, inputObj}, callId});
            throw error;
        }
    },
    /**
     * @description allows for getting models from the mongo database
     * @param {String}  [id = null] the ID of the object that will be searched for. If not defined (null), the function will return every document of the model in an array
     * @param {String}  [modelName] full name of the model that will be searched for
     * @param {String}  [logPathPrefix = ''] by default, only the model name is appended to the identifier part of the log messages generated by this function. This parameter allows to add an additional identifier prefix if the model name is ambiguous
     * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
     * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
     * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
     * @return {(Object|Array)} the found object with autopopulated properties or an array of objects if the ID is not defined
     */
    get: async ({id = null, modelName, logPathPrefix = '', logging = true, callId = null}) => {
        //Generate a new callId for our logger if it wasn't passed in the parameters
        callId = h.generateCallId(callId);
        logger.api(`Getting ${modelName}`, {logging, identifier: `api ${logPathPrefix}${modelName} get`, meta: {id}, callId});
        try{
            //Declare the object that will be returned
            let result;
            //If the id wasn't defined, find every document of the given model, otherwise find the document by its ID
            if (id === null){
                result = await mongoDb[modelName].find({}).lean({autopopulate: true});
            } else {
                result = await mongoDb[modelName].findById(id).lean({autopopulate: true});
            }
            //Return an empty array if no object was found in either case
            if ((result instanceof Array && result.length === 0) || result === null || result === undefined){
                logger.api(`Returning 0 ${modelName}s`, {logging, identifier: `api ${logPathPrefix}${modelName} get`, meta: {id}, callId});
                return [];
            }
            //Return the found docuement(s)
            logger.api(`Returning ${result instanceof Array ? result.length : 1} ${modelName}s`, {logging, identifier: `api ${logPathPrefix}${modelName} get`, meta: {id, result}, callId});
            return result;
        } catch (error){ //Log and rethrow
            logger.error(`Failed to get an existing ${modelName}: ${h.optionalStringify(error)}`, {identifier: `api ${logPathPrefix}${modelName} get`, meta: {id}, callId});
            throw error;
        }
    }
};

/**
 * The actual API functions (e.g. model controllers)
 */
module.exports = {
    __private: { //For tests
        generics
    },
    controllers: {
        ['data.user']: {
            /**
             * @description creates a new user in the mongo database
             * @param {Object}  [inputObj] a plain JS object with a structure reflecting the user's schema
             * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
             * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
             * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
             * @returns {Object} the created user object with autopopulated properties and filled default values
             */
            add: async ({inputObj, logging = true, callId = null}) => {
                return await generics.add({
                    inputObj,
                    modelName: 'data.user',
                    logging,
                    callId
                });
            },
            /**
             * @description deletes a user from the mongo database
             * @param {String}  [id] the user's identifier
             * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
             * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
             * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
             * @returns {Object} the deleted user object with autopopulated properties and filled default values
             */
            delete: async ({id, logging = true, callId = null}) => {
                return await generics.delete({
                    id,
                    modelName: 'data.user',
                    logging,
                    callId
                });
            },
            /**
             * @description updates a user in the mongo database
             * @param {String}  [id] the user's identifier
             * @param {Object}  [inputObj] a plain JS object with a structure reflecting the user's schema
             * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
             * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
             * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
             * @returns {Object} the updated user object with autopopulated properties and filled default values
             */
            update: async ({id, inputObj, logging = true, callId = null}) => {
                return await generics.update({
                    id,
                    inputObj,
                    modelName: 'data.user',
                    logging,
                    callId
                });
            },
            /**
             * @description retrieves a single user or all the users from the mongo database
             * @param {String}  [id] the user's identifier. If not defined, the function will return all the users as an Array
             * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
             * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
             * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
             * @returns {(Object|Array)} the found user object with autopopulated properties or an Array of user objects when the id parameter is ommited
             */
            get: async ({id, logging = true, callId = null}) => {
                return await generics.get({
                    id,
                    modelName: 'data.user',
                    logging,
                    callId
                });
            },
        },
    },
};