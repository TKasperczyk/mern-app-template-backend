'use strict';

/**
 * Exposes a set of functions (controllers) that allow for interacting with our database models and performing other API tasks.
 */

const dotObj = require('dot-object');
const h = require('../helpers');
const logger = require('../logger').appLogger;
const mongoDb = require('../db').mongo.models;

/**
 * A set of generic CRUD functions that can be applied to any mongo database model.
 * It was created to avoid copy-pasting the same code for every database object
 */
const generics = {
    /**
     * @description allows for saving models in the mongo database
     * @param {Object}  [inputObj] the object that will be passed to the selected model's constructor
     * @param {String}  [modelName] full name of the model that will be saved
     * @param {Function}   [modifierFunc = null] a custom function that receives the newly created object as an argument. The function can modify that object before it gets saved in the database. The modifier should return the modified object. It's useful when we our inputObj is not complete and we want to do something with its default values defined in mongoose
     * @param {String}  [logPathPrefix = ''] by default, only the model name is appended to the identifier part of the log messages generated by this function. This parameter allows to add an additional identifier prefix if the model name is ambiguous
     * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
     * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
     * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
     * @returns {Object} the saved object with autopopulated properties and filled default values
     */
    add: async ({inputObj, modelName, modifierFunc = null, logPathPrefix = '', logging = true, callId = null}) => {
        callId = h.generateCallId(callId);
        logger.api(`Adding a new ${modelName}`, {logging, identifier: `api ${logPathPrefix}${modelName} add`, meta: {inputObj}, callId});
        try{
            if (inputObj === undefined || typeof inputObj !== 'object'){
                throw new Error('Wrong inputObj argument');
            }
            if (typeof modelName !== 'string' || mongoDb[modelName] === undefined){
                throw new Error('Wrong modelName argument');
            }
            logger.api(`Creating a new ${modelName}`, {logging, identifier: `api ${logPathPrefix}${modelName} add`, callId});
            let newObj = new mongoDb[modelName](inputObj);
            if (typeof modifierFunc === 'function'){
                newObj = modifierFunc(newObj);
            }
            logger.api(`Saving the new ${modelName}`, {logging, identifier: `api ${logPathPrefix}${modelName} add`, callId});
            const savedObj = await newObj.save();
            if (savedObj){
                logger.api(`Successfully added a new ${modelName}`, {logging, identifier: `api ${logPathPrefix}${modelName} add`, meta: {savedObj}, callId});
                return mongoDb[modelName].findOne(savedObj._id); //For autopopopulate to work
            } else {
                throw new Error(`Failed to add a new ${logPathPrefix}${modelName}: unknown error`);
            }
        } catch (error){
            logger.error(`Failed to add a new ${modelName}: ${h.optionalStringify(error)}`, {identifier: `api ${logPathPrefix}${modelName} add`, meta: {inputObj}, callId});
            throw error;
        }
    },
    /**
     * @description allows for deleting models from the mongo database
     * @param {String}  [id] the ID of the object that will be deleted
     * @param {String}  [modelName] full name of the model that will be saved
     * @param {String}  [logPathPrefix = ''] by default, only the model name is appended to the identifier part of the log messages generated by this function. This parameter allows to add an additional identifier prefix if the model name is ambiguous
     * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
     * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
     * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
     * @returns {Object} the deleted object with autopopulated properties and filled default values
     */
    delete: async ({id, modelName, logPathPrefix = '', logging = true, callId = null}) => {
        callId = h.generateCallId(callId);
        logger.api(`Deleting a ${modelName}`, {logging, identifier: `api ${logPathPrefix}${modelName} delete`, meta: {id}, callId});
        try{
            if (id === undefined || typeof id !== 'string' || !(/^[a-fA-F0-9]{24}$/).test(id)){
                throw new Error('Wrong id argument');
            }
            const deletedObj = await mongoDb[modelName].findByIdAndRemove(id).exec();
            if (deletedObj){
                logger.api(`Successfully deleted a ${modelName} with an id: ${id}`, {logging, identifier: `api ${logPathPrefix}${modelName} delete`, meta: {deletedObj}, callId});
                return deletedObj;
            } else {
                throw new Error(`Failed to delete ${modelName} with id: ${id}`);
            }
        } catch (error){
            logger.error(`Failed to delete an existing ${modelName}: ${h.optionalStringify(error)}`, {identifier: `api ${logPathPrefix}${modelName} delete`, meta: {id}, callId});
            throw error;
        }
    },
    /**
     * @description allows for updating models in the mongo database
     * @param {String}  [id] the ID of the object that will be updated
     * @param {Object}  [inputObj] the object that will be passed to the $set operator
     * @param {String}  [modelName] full name of the model that will be updated
     * @param {Function}   [modifierFunc = null] a custom function that receives the newly created object as an argument. The function can modify that object before it gets updated in the database. The modifier should return the modified object. It's useful when we our inputObj is not complete and we want to do something with its default values defined in mongoose
     * @param {String}  [logPathPrefix = ''] by default, only the model name is appended to the identifier part of the log messages generated by this function. This parameter allows to add an additional identifier prefix if the model name is ambiguous
     * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
     * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
     * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
     * @returns {Object} the updated object with autopopulated properties and filled default values
     */
    update: async ({id, inputObj, modelName, modifierFunc, logPathPrefix = '', logging = true, callId = null}) => {
        callId = h.generateCallId(callId);
        logger.api(`Updating a ${modelName}`, {logging, identifier: `api ${logPathPrefix}${modelName} update`, meta: {id, inputObj}, callId});
        try{
            if (id === undefined || typeof id !== 'string' || !(/^[a-fA-F0-9]{24}$/).test(id)){
                throw new Error(`Wrong id argument: ${id === undefined ? `undefined` : id} ${typeof id} ${typeof id === `string` ? !(/^[a-fA-F0-9]{24}$/).test(id) : 'regex not applicable'}`);
            }
            if (inputObj === undefined || typeof inputObj !== 'object'){
                throw new Error(`Wrong inputObj argument`);
            }
            if (typeof modifierFunc === 'function'){
                inputObj = modifierFunc(inputObj);
            }
            inputObj = dotObj.dot(inputObj);
            const updateResult = await mongoDb[modelName].updateOne({_id: id}, {$set: inputObj}, {new: false});
            if (updateResult.ok){
                logger.api(`Successfully updated a ${modelName} with an id: ${id}`, {logging, identifier: `api ${logPathPrefix}${modelName} update`, meta: {updateResult}, callId});
                return await mongoDb[modelName].findById(id);
            } else {
                throw new Error(`Failed to update ${modelName} with id: ${id}`);
            }
        } catch (error){
            logger.error(`Failed to update an existing ${modelName}: ${h.optionalStringify(error)}`, {identifier: `api ${logPathPrefix}${modelName} update`, meta: {id, inputObj}, callId});
            throw error;
        }
    },
    /**
     * @description allows for getting models from the mongo database
     * @param {String}  [id = null] the ID of the object that will be searched for. If not defined (null), the function will return every document of the model in an array
     * @param {String}  [modelName] full name of the model that will be searched for
     * @param {String}  [logPathPrefix = ''] by default, only the model name is appended to the identifier part of the log messages generated by this function. This parameter allows to add an additional identifier prefix if the model name is ambiguous
     * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
     * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
     * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
     * @return {(Object|Array)} the found object with autopopulated properties or an array of objects if the ID is not defined
     */
    get: async ({id = null, modelName, logPathPrefix = '', logging = true, callId = null}) => {
        callId = h.generateCallId(callId);
        logger.api(`Getting ${modelName}`, {logging, identifier: `api ${logPathPrefix}${modelName} get`, meta: {id}, callId});
        try{
            let result = null;
            if (id === null){
                result = await mongoDb[modelName].find({}).lean({autopopulate: true});
            } else {
                result = await mongoDb[modelName].findById(id).lean({autopopulate: true});
            }

            if ((result instanceof Array && result.length === 0) || result === null || result === undefined){
                logger.api(`Returning 0 ${modelName}s`, {logging, identifier: `api ${logPathPrefix}${modelName} get`, meta: {id}, callId});
                return [];
            }
            logger.api(`Returning ${result instanceof Array ? result.length : 1} ${modelName}s`, {logging, identifier: `api ${logPathPrefix}${modelName} get`, meta: {id, result}, callId});
            return result;
        } catch (error){
            logger.error(`Failed to get an existing ${modelName}: ${h.optionalStringify(error)}`, {identifier: `api ${logPathPrefix}${modelName} get`, meta: {id}, callId});
            throw error;
        }
    }
};

/**
 * The actual API functions (e.g. model controllers)
 */
module.exports = {
    __private: {
        generics
    },
    controllers: {
        ['data.user']: {
            /**
             * @description creates a new user in the mongo database
             * @param {Object}  [user] a plain JS object with a structure reflecting the user's schema
             * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
             * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
             * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
             * @returns {Object} the created user object with autopopulated properties and filled default values
             */
            add: async ({user, logging = true, callId = null}) => {
                return await generics.add({
                    inputObj: user,
                    modelName: 'data.user',
                    logPathPrefix: 'user ',
                    logging,
                    callId
                });
            },
            /**
             * @description deletes a user from the mongo database
             * @param {String}  [id] the user's identifier
             * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
             * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
             * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
             * @returns {Object} the deleted user object with autopopulated properties and filled default values
             */
            delete: async ({id, logging = true, callId = null}) => {
                return await generics.delete({
                    id,
                    modelName: 'data.user',
                    logPathPrefix: 'user ',
                    logging,
                    callId
                });
            },
            /**
             * @description updates a user in the mongo database
             * @param {String}  [id] the user's identifier
             * @param {Object}  [user] a plain JS object with a structure reflecting the user's schema
             * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
             * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
             * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
             * @returns {Object} the updated user object with autopopulated properties and filled default values
             */
            update: async ({id, user, logging = true, callId = null}) => {
                return await generics.update({
                    id,
                    inputObj: user,
                    modelName: 'data.user',
                    logPathPrefix: 'user ',
                    logging,
                    callId
                });
            },
            /**
             * @description retrieves a single user or all the users from the mongo database
             * @param {String}  [id] the user's identifier. If not defined, the function will return all the users as an Array
             * @param {Object}  [user] a plain JS object with a structure reflecting the user's schema
             * @param {Boolean} [logging = true] allows to controll whether log messages are generated or not
             * @param {String}  [callId = null] if defined, a new callId won't be generated for the log messages generated by this function
             * @throws {Error} will throw if the arguments are wrong or something goes wrong when interacting with the database
             * @returns {(Object|Array)} the found user object with autopopulated properties or an Array of user objects when the id parameter is ommited
             */
            get: async ({id, logging = true, callId = null}) => {
                return await generics.get({
                    id,
                    modelName: 'data.user',
                    logPathPrefix: 'user ',
                    logging,
                    callId
                });
            },
        },
    },
};